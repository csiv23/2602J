#pragma config(Sensor, dgtl1,  RightFrontEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  RightBackEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  LeftFrontEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  LeftBackEncoder, sensorQuadEncoder)
#pragma config(Motor,  port2,           rightSideDrive, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           mobileGoalMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           mainLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           turntableMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftSideDrive, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           gripMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           liftExtension, tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                          - Code Chooser -                                          *|
|*                                      ROBOTC on VEX 2.0 Cortex                                      *|
|*                                                                                                    *|
|*  This program uses the Display functions of ROBOTC on the VEX 2.0 Cortex platform.                 *|
|*  IIt allows the user to choose from 4 different pieces of code using the left and right buttons    *|
|*  on the VEX LCD. Once the center button is pressed, the code corresponding with the choice is run. *|
|*  This code can be adapted for competition based settings - just place the code for the first       *|
|*  switch case in the pre_auton function, and the code for the second switch in the autonomous task. *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  The LCD Screen must be attached to UART Port 2.                                             *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    UART Port 2         none                VEX LCD               VEX LCD Screen                    *|
|*    Motor Port 2        rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor Port 3        leftMotor           VEX 3-wire module     Left side motor                   *|
\*----------------------------------------------------------------------------------------------------*/

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

//Wait for Press--------------------------------------------------
void waitForPress()
{
  while(nLCDButtons == 0){}
  wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
  while(nLCDButtons != 0){}
  wait1Msec(5);
}
//----------------------------------------------------------------

task main()
{
  //Clear LCD
  clearLCDLine(0);
  clearLCDLine(1);
  //Declare count variable to keep track of our choice
  int count = 0;
  //Loop while center button is not pressed
  while(nLCDButtons != centerButton)
  {
    //Switch case that allows the user to choose from 4 different options
    switch(count){
    case 0:
      //Display first choice
      displayLCDCenteredString(0, "parkingautonomous");
      displayLCDCenteredString(1, "<     Enter    >");
      waitForPress();
      //Increment or decrement "count" based on button press
      if(nLCDButtons == leftButton)
      {
        waitForRelease();
        count = 3;
      }
      else if(nLCDButtons == rightButton)
      {
        waitForRelease();
        count++;
      }
      break;
    case 1:
      //Display second choice
      displayLCDCenteredString(0, "autonomous 10ptzone");
      displayLCDCenteredString(1, "<     Enter    >");
      waitForPress();
      //Increment or decrement "count" based on button press
      if(nLCDButtons == leftButton)
      {
        waitForRelease();
        count--;
      }
      else if(nLCDButtons == rightButton)
      {
        waitForRelease();
        count++;
      }
      break;
    case 2:
      //Display third choice
      displayLCDCenteredString(0, "autonomous 20ptzone");
      displayLCDCenteredString(1, "<     Enter    >");
      waitForPress();
      //Increment or decrement "count" based on button press
      if(nLCDButtons == leftButton)
      {
        waitForRelease();
        count--;
      }
      else if(nLCDButtons == rightButton)
      {
        waitForRelease();
        count++;
      }
      break;
      case 3:
      //display fourth choice
      displayLCDCenteredString(0, "drive test");
      displayLCDCenteredString(1, "<     Enter    >");
      waitForPress();
      //Increment or decrement "count" based on button press
       if(nLCDButtons == leftButton)
      {
        waitForRelease();
        count--;
      }
      else if(nLCDButtons == rightButton)
      {
        waitForRelease();
        count++;
      }
      break;
      case 4:
      //display fifth choice
      displayLCDCenteredString(0, "arm test");
      displayLCDCenteredString(1, "<     Enter    >");
      waitForPress();
      //Increment or decrement "cobunt" based on button press
       if(nLCDButtons == leftButton)
      {
        waitForRelease();
        count--;
      }
      else if(nLCDButtons == rightButton)
      {
        waitForRelease();
        count++;
      }
      break;
    default:
      count = 0;
      break;
    }
  }
  //Clear LCD
  clearLCDLine(0);
  clearLCDLine(1);
  //Switch Case that actually runs the user choice
  switch(count){
  case 0:
    //If count = 0, run the code correspoinding with choice 1
    displayLCDCenteredString(0, "10ptzone");
    displayLCDCenteredString(1, "is running!");

    // autonomous 1 is run
	int forwards;
	int backwards;
	int nada;

	forwards = 95;
	backwards = -95;
	nada = 0;
	clearTimer(T1);
	while(time1[T1] < 15000)
	{
		motor[rightSideDrive] = forwards;
		motor[leftSideDrive] = forwards;
		wait1Msec(3000);
		//drives forwards
		motor[rightSideDrive] = nada;
		motor[leftSideDrive] = nada;
		wait1Msec(0);
		//stops
		motor[mobileGoalMotor] = backwards;
		wait1Msec(500);
		//mobile goal goes out
		motor[rightSideDrive] = forwards;
		motor[leftSideDrive] = forwards;
		wait1Msec(200);
		//drive forwards to snag mobile goal
		motor[mainLift] = backwards;
		wait1Msec(500);
		//lower lift to line up
		motor[gripMotor] = backwards;
		wait1Msec(300);
		//release cone
		motor[mobileGoalMotor] = forwards;
		wait1Msec(500);
		//load mobile goal
		motor[rightSideDrive] = forwards;
		motor[leftSideDrive] = backwards;
		wait1Msec(1000);
		//reverse direction
		motor[rightSideDrive] = forwards;
		motor[leftSideDrive] = forwards;
		wait1Msec(2500);
		//drive back to scoring pipes
		//might need to change time for wait variable
		motor[mobileGoalMotor] = backwards;
		wait1Msec(500);
		//release mobile goal
		motor[rightSideDrive] = backwards;
		motor[leftSideDrive] = backwards;
		wait1Msec(1000);
		//drive out of scoring pipes
		motor[rightSideDrive] = nada;
		motor[leftSideDrive] = nada;
		motor[mainLift] = nada;
		motor[liftExtension] = nada;
		motor[gripMotor] = nada;
		motor[mobileGoalMotor] = nada;
		wait1Msec(10000);
	}
    //insert autonomous 1 code here
    break;
  case 1:
    //If count = 1, run the code correspoinding with choice 2
    displayLCDCenteredString(0, "20ptzone");
    displayLCDCenteredString(1, "is running!");

	forwards = 95;
	backwards = -95;
	nada = 0;
	clearTimer(T1);
	while(time1[T1] < 15000)
	{
		motor[rightSideDrive] = forwards;
		motor[leftSideDrive] = forwards;
		wait1Msec(3000);
		//drives forwards
		motor[rightSideDrive] = nada;
		motor[leftSideDrive] = nada;
		wait1Msec(0);
		//stops
		motor[mobileGoalMotor] = backwards;
		wait1Msec(500);
		//mobile goal goes out
		motor[rightSideDrive] = forwards;
		motor[leftSideDrive] = forwards;
		wait1Msec(200);
		//drive forwards to snag mobile goal
		motor[mainLift] = backwards;
		wait1Msec(500);
		//lower lift to line up
		motor[gripMotor] = backwards;
		wait1Msec(300);
		//release cone
		motor[mobileGoalMotor] = forwards;
		wait1Msec(500);
		//load mobile goal
		motor[rightSideDrive] = forwards;
		motor[leftSideDrive] = backwards;
		wait1Msec(1000);
		//reverse direction
		motor[rightSideDrive] = forwards;
		motor[leftSideDrive] = forwards;
		wait1Msec(2500);
		//drive back to scoring pipes
		//might need to change time for wait variable
		motor[mobileGoalMotor] = backwards;
		wait1Msec(500);
		//release mobile goal
		motor[rightSideDrive] = backwards;
		motor[leftSideDrive] = backwards;
		wait1Msec(1000);
		//drive out of scoring pipes
		motor[rightSideDrive] = nada;
		motor[leftSideDrive] = nada;
		motor[mainLift] = nada;
		motor[liftExtension] = nada;
		motor[gripMotor] = nada;
		motor[mobileGoalMotor] = nada;
		wait1Msec(10000);
	}
    break;
  case 2:
    //If count = 2, run the code correspoinding with choice 3
    displayLCDCenteredString(0, "parking");
    displayLCDCenteredString(1, "is running!");


	forwards = 95;
	backwards = -95;
	nada = 0;
	clearTimer(T1);
	while(time1[T1] < 15000)
	{
		motor[rightSideDrive] = forwards;
		motor[leftSideDrive] = forwards;
		wait1Msec(3000);
		//drives forwards
		motor[rightSideDrive] = nada;
		motor[leftSideDrive] = nada;
		wait1Msec(0);
		//stops
		motor[rightSideDrive] = forwards;
		motor[leftSideDrive] = forwards;
		wait1Msec(200);
		//drive forwards to parking zone
		motor[rightSideDrive] = nada;
		motor[leftSideDrive] = nada;
		wait1Msec(200);
		//stop and wait
 }

    break;
  case 3:
    //If count = 3, run the code correspoinding with choice 4
    displayLCDCenteredString(0, "drivetest");
    displayLCDCenteredString(1, "is running!");

   motor(rightSideDrive) = forwards;
   motor(leftSideDrive) = forwards;
  motor(mobileGoalMotor) = forwards;

   wait1Msec(500);


    break;
    case 4;
    //if count = 4, run the code corresponding with choice 5
    displayLCDCenteredString(0, "armtest");
    displayLCDCenteredString(1, "is running!");

    motor(mainLift) = forwards;
    motor(turntableMotor) = forwards;
    motor(gripMotor) = forwards;
    motor(liftExtension) = forwards;

    wait1Msec(500);


  default:
    displayLCDCenteredString(0, "No valid choice");
    displayLCDCenteredString(1, "was made!");
    break;
  }
}
